;;
;;Copyright (C) 2023 Pierre Vittet <pvittet|at|murena|dot|io>
;;
;;This program is free software: you can redistribute it and/or modify
;;it under the terms of the GNU General Public License as published by
;;the Free Software Foundation, either version 3 of the License, or
;;(at your option) any later version.
;;
;;This program is distributed in the hope that it will be useful,
;;but WITHOUT ANY WARRANTY; without even the implied warranty of
;;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;GNU General Public License for more details.
;;
;;You should have received a copy of the GNU General Public License
;;along with this program.  If not, see <https://www.gnu.org/licenses/>.

(ns quilchart.dataGraph)
;################# Types expected to be visible externally. #################

;;A dot has a x and y position. It is a logical postion, not a displayed postion.
(defrecord Dot [logical_x logical_y])
;DDot is like Dot but is expected to be used for display coordinate
(defrecord DDot [display_x display_y])
;Un datafield correspond à l'ensemble des points d'une courbe que l'on veut afficher.
;Un datafield possède un nom qui sert d'identifiant au datafield
;Il possède en plus une liste de points
(defrecord DataField [dfid intid dots])

;;A graph contains a set of datafields curves.
;;dataFields is a map of DataField, using a unique id as key (dfid).
(defrecord Graph [id dataFields])

(defrecord ThemeData [background_color
                      axis_color
                      info_color
                      datafields_colors ;list of color for every datafield
                      grid_color
                      ]
)

;Possible options for the program.
(def possible_options [:size_win_x :size_win_y :title :left_border :right_border :top_border :bottom_border :display_mode :theme])

;############### END Types expected to be visible externally. ###############


;################# Internal Types #################
(defrecord ZoomManagement [is_zoomed  ; true if the graph is not full size
                           zoom_min_x ; min x value accepted at this zoom level
                           zoom_max_x ; max x value accepted at this zoom level
                           zoom_min_y ; min y value accepted at this zoom level
                           zoom_max_y ; max y value accepted at this zoom level
                           ;We speak are about x and y has 'logical values' and not pixel stuff
                           ])

;############# It is mostly enriched structures to avoid recomputing stuff ##############

;Internal info linked to a datafield
(defrecord IntDataField [dfid         ;name of the datafield
                         xmin_val          ;minimum logical x value
                         xmax_val          ;maximum logical x value
                         ymin_val          ;minimum logical y value
                         ymax_val          ;minimum logical y value
                         ])


;Internal info linked to a graph
(defrecord IntGraph [size_win_x     ;width of the windows
                     size_win_y     ;height of the windows
                     width_x_axis   ;width of the x axis
                     height_y_axis  ;height of the y axis
                     internal_datafields ;info linked to the internal datafields, a list of IntDataField
                     xmin_val          ;xmin of every datafields
                     xmax_val          ;xmax of every datafields
                     ymin_val          ;ymin of every datafields
                     ymax_val          ;ymax of every datafields
                     ])

;On conserve ici des informations associés à l'axe X qui peuvent être utilisées dans ces différentes fonctions
(defrecord XData [min_x
                  max_x
                  min_y
                  max_y
                  min_x_val
                  max_x_val
                  min_y_val
                  max_y_val
                  total_val_duration
                  ]
)



;################# END Internal Types #################

(def _next_graph_id (atom 1))

;To allow the library to manage several graphes on same times, we need to be
;able to identify graph by id. This id is a simple integer, uniquelly generated
;by this function.
(defn get-new-graph-id []
  (let [id @_next_graph_id]
    (swap! _next_graph_id (fn [i] (inc i)))
   )
)


(def _next_datafield_id (atom {}))
;This id is a simple integer, uniquelly generated by this function.
(defn get-new-datafield-id [id]
  (let [curid (get @_next_datafield_id id 0)]
    (swap! _next_datafield_id (fn [current] (assoc current id (inc curid))))
    curid
   )
)



;map of all actives graphes
;type Graph
(def _prog_options(atom {}))

(defn set-prog-options [id options]
  (swap! _prog_options (fn [cur_options] (assoc cur_options id options)))
)

(defn get-prog-options [id]
  (get @_prog_options id)
)

;map of all actives graphes
;type Graph
(def _current_graph(atom {}))

(defn set-current-graph [id graph]
  (swap! _current_graph (fn [cur_graph] (assoc cur_graph id graph)))
)

(defn get-current-graph [id]
  (get @_current_graph id)
)


(def _prev_dgraph(atom {}))

(defn set-prev-display-graph [id dgraph]
  (swap! _prev_dgraph (fn [graph] (assoc graph id dgraph)))
)

(defn get-prev-display-graph [id]
  (get @_prev_dgraph id)
)



;;map of all new graphes
;type Graph
(def _new_graph (atom {}))
(defn set-new-graph [id graph]
  (swap! _new_graph (fn [cur_graph] (assoc cur_graph id graph)))
  )

(defn get-new-graph [id]
  (get @_new_graph id)
  )

;;map of dots to add to a graph
(def _dots_to_add (atom {}))
(defn set-dots-to-add [id dots]
  (swap! _dots_to_add (fn [cur_map] (assoc cur_map id dots)))
  )

(defn get-dots-to-add [id]
  (get @_dots_to_add id)
  )

;;map of all theme
;type ThemeData
(def _graph_theme (atom {}))
(defn set-graph-theme [id theme]
  (swap! _graph_theme (fn [cur_graph] (assoc cur_graph id theme)))
  )

(defn get-graph-theme [id]
  (get @_graph_theme id)
  )


;;internal info of all graph
;type IntGraph
(def _graph_internal (atom {}))
(defn set-graph-internal [id internal]
  (swap! _graph_internal (fn [cur_graph] (assoc cur_graph id internal)))
  )

(defn get-graph-internal [id]
  (get @_graph_internal id)
  )

;;internal xData info of all graph
(def _xData_info (atom {}))
(defn set-xData-info [id xData]
  (swap! _xData_info (fn [cur_data] (assoc cur_data id xData)))
  )

(defn get-xData-info [id]
  (get @_xData_info id)
  )




;the ref variable containing info about the applied zoom management.
(def _zoom_management (atom {}))
(defn set-zoom-management [id zoom_management]
  (swap! _zoom_management (fn [cur_zoom] (assoc cur_zoom id zoom_management)))
  )

(defn get-zoom-management [id]
  (get @_zoom_management id)
  )

;the ref variable containing info about should the graph be redrawn.
(def _need_redraw (atom {}))
(defn set-need-redraw [id need_redraw]
  (swap! _need_redraw (fn [cur_redraw] (assoc cur_redraw id need_redraw)))
  )

(defn get-need-redraw [id]
  (get @_need_redraw id)
  )

;the ref variable containing info about should the graph be recomputed 
(def _need_recompute (atom {}))
(defn set-need-recompute [id need_recompute]
  (swap! _need_recompute (fn [cur_recompute] (assoc cur_recompute id need_recompute)))
  )

(defn get-need-recompute [id]
  (get @_need_recompute id)
  )

(def _graph_has_changed (atom {}))
(defn set-graph-has-changed [id has-changed]
  (swap! _graph_has_changed (fn [cur] (assoc cur id has-changed)))
  )

(defn get-graph-has-changed [id]
  (get @_graph_has_changed id)
  )



;_need-pause represent a boolean. When it is true, no need to compute data, no
;need to display them, only raw background.
(def _need_pause (atom {}))
(defn set-need-pause [id need_pause]
  (swap! _need_pause (fn [cur_redraw] (assoc cur_redraw id need_pause)))
  )

(defn get-need-pause [id]
  (get @_need_pause id)
  )


(def _wd_resize_at (atom {}))
(defn set-wd-resize-at [id resize_at]
  (swap! _wd_resize_at (fn [cur] (assoc cur id resize_at)))
  )

(defn get-wd-resize-at [id]
  (get @_wd_resize_at id)
  )


;mouse-presed-start is null if the mouse has not been presed in the area of the graph.
;It become an (x,y) tuple on the coordinate at which it was first presed if it has been presed.
(def _mouse-presed-start (atom {}))

(defn set-mouse-presed-start [id mouse-presed]
  (swap! _mouse-presed-start (fn [cur_mouse] (assoc cur_mouse id mouse-presed)))
  )

(defn get-mouse-presed-start [id]
  (get @_mouse-presed-start id)
  )



;mouse-presed-end is like mouse-presed-start but is set at the moment the mouse is released.
;mouse-presed-start and mouse-presed-end are used to compute the zoom.
(def _mouse-presed-end (atom {}))

(defn set-mouse-presed-end [id mouse-presed]
  (swap! _mouse-presed-end (fn [cur_mouse] (assoc cur_mouse id mouse-presed)))
  )

(defn get-mouse-presed-end [id]
  (get @_mouse-presed-end id)
  )

(def _draw-mouse-pos (atom {}))

(defn set-draw-mouse-pos [id mouse-pos]
  (swap! _draw-mouse-pos (fn [cur_mouse] (assoc cur_mouse id mouse-pos)))
  )

(defn get-draw-mouse-pos [id]
  (get @_draw-mouse-pos id)
  )


